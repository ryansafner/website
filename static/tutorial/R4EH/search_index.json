[
["index.html", "R For Econometrics: A Modest Handbook Chapter 1 Prerequisites 1.1 How to Read this Guide", " R For Econometrics: A Modest Handbook Ryan Safner (safner@hood.edu) Last Updated: 2018-12-15 Chapter 1 Prerequisites Open Source: The raw (.Rmd) code used to produce this guide, along with the guide itself, are available on GitHub, and are updated regularly. GitHub does not automatically render HTML, so download the HTML file and open it, or view it where I host it on my website. Note to Students: This is a work in progress, check the date at the top for when this was last updated. This compiles all of my instructions, advice, and examples from econometrics class lectures regarding R. It also contains some advanced material that I did not or will not cover in class, but will be useful to know for future data analysis and understanding or diagnosing problems. Note to Everyone Else: This guide is oriented primarily for my Econometrics class at Hood College, but should be of wider use to anyone interested in learning R for data analysis. Lecture slides, handouts, and guides (both PDFs and source code in R Markdown) are openly available on GitHub. See also my companion guide to using R Markdown to more effectively manage your entire workflow (text, data analysis, tables, graphs, and citations!) in a single plain text file and make your work reproducible and shareable, hosted on my website, with source available on GitHub This guide is meant to be a somewhat comprehensive resource such that you can come back to different sections when you encounter a specific limitation or problem in your own work. I do not recommend reading through this guide from start to finish, or in order. 1.1 How to Read this Guide As an econometrics student, the core of your data analysis life will be working with data.frames (think “spreadsheets”, where each row is an observation and each column is a variable). You will: - import data into a data.frame - transform (“wrangle”) data into more useful variables or data.frames - plot data from data.frames (in histograms, scatterplots, etc.) - run regressions using data from data.frames This guide attempts to introduce you to R from the ground up, which means it starts with simpler types of objects than data.frames (namely, vectors). I would not necessarily recommend reading from beginning to end. The first two sections describe a lot about R as a language and discuss different types of R objects, data types, and commands. Starting at the very beginning, reading them will seem overwhelming. They will become more useful to return to for reference later, once you have some practice under your belt. "],
["basics.html", "Chapter 2 Basics 2.1 Operating R Studio 2.2 Working Directory (wd) 2.3 Packages 2.4 Useful Packages 2.5 Calculations 2.6 Hints for Writing Code 2.7 Getting Help", " Chapter 2 Basics 2.1 Operating R Studio There are a few ways you can use R Studio: Command line/Console: writing each command by itself and copying down the result as needed Great for testing individual commands to see what happens Not reproducible! Not saved! NOT RECOMMENDED! .R files: A sequence of commands (and hopefully comments) saved as a script, the entire script is run all at once Can test individual commands in command line and then put good commands in .R file Equivalent to a .do file for Stata Reproducible, saved, commented R Markdown (.Rmd) files: A plain text document written in R Markdown language Allows for individual chunks of R code to be run individually (great for testing one command instead of all at once) Reproducible, saved, commented as if a normal document Can write an entire document (text, equations, R commands, figures, tables, etc) with one file! Can export to html, MS Word, Beamer, etc! Markdown is a language that is intuitive, simple, human- and machine-readable Rstudio Windows 2.1.1 Keyboard Shortcuts Ctrl+2: move cursor to console Ctrl (Cmd on Mac)+Enter: run current line (from editor) in console Ctrl (Cmd on Mac)+Enter Uparrow: retrieve recent commands in console Ctrl (Cmd on Mac)+Uparrow: search previous commands Option -: insert assignment operator (&lt;-) Ctrl (Cmd on Mac)+Shift+M: insert pipe operator (%&gt;%) 2.2 Working Directory (wd) R assumes a default (often inconvenient) working directory on your computer this is where it thinks it will load any files you want to load and save anything you want to save by default Find out where R currently thinks this is with getwd() this is often Operating System specific, e.g.: Mac: /Users/yourusername/ Windows: C:/Users/yourusername/Documents/ you can move everything you want to load into this folder on your computer (and save everything there too), but this may be inconvenient Change the working directory to wherever you plan on keeping your related data and documents with setwd(&quot;/path/to/folder&quot;) you can move to a new wd relative to the current working directory: move down a folder by typing the folder name with a / after i e.g. to move from /Ryansafner/Documents/ to /Ryansafner/Documents/Econometrics/ move up one folder in a hierarchy with .. e.g. to move from /Ryansafner/Documents/ to /Ryansafner/Downloads, use setwd(&quot;../Downloads/&quot;) to move up from the Documents folder to Ryansafner folder, then down to Downloads 2.3 Packages Packages are extensions of base R designed by users Remember, R is open source, packages are usually published first on Github Official packages distributed and documented through CRAN To use a (previously-installed) package (note the “”), use the library() command: library(&quot;packagename&quot;) If you do not have a package, they are easy to install with (note the plural “s”) install.packages(&quot;packagename&quot;) To install or load multiple packages at once, we can use the c() function to select multiple packages (see below) library(c(&quot;gapminder&quot;,&quot;ggplot2&quot;,&quot;dplyr&quot;)) 2.4 Useful Packages There are several packages we will use often (and are featured later in this guide) Packages are often very well-documented with explanations and examples Google each package for more information 2.5 Calculations R can be used as a calculator Basic operations +, -, *, / More advanced math operators like exponents, logarithms, trigonometric functions, etc 2+2 ## [1] 4 6^2 # 6 to the second power (i.e. squared) ## [1] 36 sqrt(100/4) # square root ## [1] 5 log(5) # logarithm ## [1] 1.609438 sin(2*pi) # sin ## [1] -2.449294e-16 factorial(5) # factorial (e.g. 5!) ## [1] 120 choose(2,6) # binomial choose function ## [1] 0 # order of operations matters 3*3+4 ## [1] 13 3*(3+4) ## [1] 21 Note on Notation: R often reports very large (or very small) numbers in scientific notation with e For positive e: the number of zeros (or digits after the decimal point) to the right of a number e.g. \\(1.25e6 = 1.25 \\times 10^6 = 1,250,000\\) For negative e: one less than the number of zeros (or digits after the decimal point) to the left of a number e.g. \\(1.25e-6 = 1.25 \\times 10^{-6} = 0.00000125\\) 2.6 Hints for Writing Code 2.6.1 Naming Objects Object names cannot start with a digit or contain a space or comma FOR THE LOVE OF GOD AVOID SPACES IN GENERAL You’ve seen webpages intended to be called &quot;my webpage in html&quot; turned into http://my%20webpage%20in%20html.html Consider both your R objects and your files and folder names on your computer…(/School/ECON_480_Econometrics/Homeworks_and_Data/) It will be wise to adopt some consistent standard for demarcating names: i.use.snake.case otherPeopleUseCamelCase some_people_use_underscores And_aFew.People_RENOUNCEconvention 2.6.2 Commenting Always comment your commands! Describe what you are doing so someone else (or you, 5 years later) can understand what is happening and why! Use the hashtag # to start a comment (R ignores everything on that line after the hashtag) Can be made its own line or at the end of lines e.g. # Run regression of y on x, save as reg1 reg1&lt;-lm(y~x, data=mydata) # runs regression using mydata summary(reg1$coefficients) # prints coefficients 2.6.3 Managing Your Workflow Save often! Better yet, ask me about version control and GitHub 2.7 Getting Help You can get documentation, explanations, and examples of every command in R simply type ?commandname or help(&quot;commandname&quot;) Meet your new friend: Meet your new best friend: The only way to learn coding is by tweaking existing examples, messing up, and searching the internet for help! "],
["objects.html", "Objects 2.8 Vectors", " Objects R is an object-oriented programming language, meaning we will almost always store data in objects and run functions on those objects. We assign values to objects using the assignment operator (&lt;-)1 myobject&lt;-value The keyboard shortcut for inserting &lt;- (inside the Console or an R chunk) is Alt+- (on Windows) or Option+- (on Mac). Functions take the form: functionname(myobject) Functions can have other functions for arguments (the object the function is run on), e.g. round(rnorm(5),2) # rnorm(5) takes 5 random draws from a normal distribution # then round(, 2) rounds the result to 2 decimal places 2.8 Vectors The simplest data structure in R is a vector, simply a collection of objects or elements. To construct a vector, use the “combine/concatenate” function “c()” As an example, let’s make a vector of the numbers 1 through 5, called v. v&lt;-c(1,2,3,4,5) We can also build vectors via generating mathematical series with the : operator, which lists all integers in a series from beginning:end. v&lt;-1:5 To inspect an object, we simply “call” it up by typing the name of the object to print its contents. v ## [1] 1 2 3 4 5 2.8.1 Functions Since a vector is an object, we can run functions on that object. Let’s start with some simple mathematical functions, such as taking the sum and taking the mean of our simple vector v. sum(v) ## [1] 15 mean(v) ## [1] 3 Functions in R are “vectorized,” meaning the function is run on every object inside a vector. We can perform mathematical operations on a vector as a whole: sum(1:5) ## [1] 15 mean(1:5) ## [1] 3 Think of the assignment operator like like an \\(=\\) sign, but we want to avoid using the equals sign. &lt;- was originally its own key on early computer keyboards.↩ "],
["other-object-types.html", "Chapter 3 Other Object Types 3.1 Lists 3.2 Matrix 3.3 Data Frame", " Chapter 3 Other Object Types 3.1 Lists A list is a non-atomic vector, meaning you can gather data elements of different classes in one object mylist&lt;-list(5, pi, TRUE, 4.3, &quot;cabbage&quot;) class(mylist) ## [1] &quot;list&quot; Another great property of lists is that elements of the list can themselves be vectors vectored.list&lt;-list(c(1.82, 1940, 93.20, 192.917), c(&quot;Orange&quot;, &quot;Cyan&quot;, &quot;Pink&quot;), c(TRUE, FALSE, TRUE, TRUE, FALSE, TRUE, FALSE, FALSE)) str(vectored.list) # look at structure of the list ## List of 3 ## $ : num [1:4] 1.82 1940 93.2 192.92 ## $ : chr [1:3] &quot;Orange&quot; &quot;Cyan&quot; &quot;Pink&quot; ## $ : logi [1:8] TRUE FALSE TRUE TRUE FALSE TRUE ... We can create a label for each element in a list, called a name vectored.list&lt;-list(numbers=c(1.82, 1940, 93.20, 192.917), # first element is a vector called &#39;numbers&#39; colors=c(&quot;Orange&quot;, &quot;Cyan&quot;, &quot;Pink&quot;), # second element is a vector called `colors` logic=c(TRUE, FALSE, TRUE, TRUE, FALSE, TRUE, FALSE, FALSE)) # third element is a vector called `logic` vectored.list ## $numbers ## [1] 1.820 1940.000 93.200 192.917 ## ## $colors ## [1] &quot;Orange&quot; &quot;Cyan&quot; &quot;Pink&quot; ## ## $logic ## [1] TRUE FALSE TRUE TRUE FALSE TRUE FALSE FALSE The names command prints (or changes) the name of the label of each element in the list names(vectored.list) # print the names of the list elements ## [1] &quot;numbers&quot; &quot;colors&quot; &quot;logic&quot; names(vectored.list)&lt;-c(&quot;name1&quot;,&quot;name2&quot;,&quot;name3&quot;) # rename the lables to &#39;name1&#39;, &#39;name2&#39;, and &#39;name3&#39; names(vectored.list) # print new names ## [1] &quot;name1&quot; &quot;name2&quot; &quot;name3&quot; vectored.list # print list with new names ## $name1 ## [1] 1.820 1940.000 93.200 192.917 ## ## $name2 ## [1] &quot;Orange&quot; &quot;Cyan&quot; &quot;Pink&quot; ## ## $name3 ## [1] TRUE FALSE TRUE TRUE FALSE TRUE FALSE FALSE 3.2 Matrix Everything thus far has been 1 dimension, but we often work with 2-dimensional data Rows are observations Columns are variables A matrix matrix() command creates a matrix by column, can define number of rows with nrow=, R will divide the elements into equal number of columns matrix1&lt;-matrix(c(1,2,3,4,5,6),nrow=3) # make a 3-row matrix matrix1 ## [,1] [,2] ## [1,] 1 4 ## [2,] 2 5 ## [3,] 3 6 3.3 Data Frame The most important object in R is a data frame (what you call a “spreadsheet”), used for statistics, plots, regressions, etc “Rectangular” data, rows are observations, columns are variables Can hold variables of different classes (e.g. a quantitative variable like income, a character variable like name, etc) In essence, data frames are actually lists (where each list object itself is a vector) All vectors (columns) must have the same length! df&lt;-data.frame(x = 1:3, y = c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;), z = c(TRUE, FALSE, TRUE)) df ## x y z ## 1 1 a TRUE ## 2 2 b FALSE ## 3 3 c TRUE "],
["data-classes.html", "Chapter 4 Data Classes 4.1 Checking or Reclassifying Objects", " Chapter 4 Data Classes Vectors must contain the same type of elements (e.g. numerical or text) Technically this refers to atomic vectors (nearly all vectors are atomic) Vectors with “mixed” types will convert all elements to the lowest-common denominator, e.g. character You can always check the type of vector using class() mixed&lt;-c(5, pi, TRUE, 4.3, &quot;cabbage&quot;) class(mixed) ## [1] &quot;character&quot; 4.0.1 Numeric Numeric (aka “double”), as it sounds, can perform mathematical operations numeric&lt;-c(1,2,3,4,5) There are two types of numeric objects: double and integer 4.0.2 Double If numeric values contain decimal points, they are technically called floating point double or simply double class R may simply call them numeric, but contrast with integer below double&lt;-c(pi,2.34,9.99) class(double) ## [1] &quot;numeric&quot; typeof(double) # will return the more specific type ## [1] &quot;double&quot; is.double(double) # a logical test to see if object is &quot;double&quot; type ## [1] TRUE is.integer(double) # a logical test to see if object is &quot;integer&quot; type ## [1] FALSE 4.0.2.1 Integer If numeric values are all whole numbers, they are integer class integers&lt;-c(1,2,3,4) class(integers) ## [1] &quot;numeric&quot; typeof(integers) ## [1] &quot;double&quot; is.double(double) ## [1] TRUE is.integer(double) ## [1] FALSE 4.0.3 Logical Logical is a series of binary elements or statements that can either be TRUE or FALSE logical&lt;-c(TRUE,FALSE,FALSE,TRUE) We can perform logical tests with common operators: &lt; less than &gt; greater than &lt;= less than or equal to (\\(\\leq\\)) &gt;= greater than or equal to (\\(\\geq\\)) == is equal to (note two equals signs are needed!) != is not equal to %in% is a member of a set (\\(\\in\\)) 3==4 #is 3 equal to 4? ## [1] FALSE 3&lt;4 # is three less than 4? ## [1] TRUE 3&lt;=4 # is three less than or equal to 4? ## [1] TRUE 3&gt;4 # is three greater than 4? ## [1] FALSE 3!=4 # is three not equal to four? ## [1] TRUE 3 %in% c(0,1,2) # is three in the following set of numbers? ## [1] FALSE 3 %in% c(0,1,2,3) # is three in the following set of numbers? ## [1] TRUE We are not limited to using numeric data, R can also perform logical tests on other classes of variable, like characters (which need quotes): &quot;red&quot;==&quot;blue&quot; # is red the same as blue? ## [1] FALSE &quot;red&quot;!=&quot;blue&quot; # is red not equal to blue? ## [1] TRUE political.party&lt;-c(&quot;Republican&quot;,&quot;Democrat&quot;) # define political party as a set of Republican and Democrat &quot;Libertarian&quot; %in% political.party # check if Libertarian is in the set of political parties we created ## [1] FALSE &quot;Democrat&quot; %in% political.party # check if Democrat is in our set of political parties ## [1] TRUE We can also perform more than one test at a time with multiple conditions: &amp; AND | OR 2==2 &amp; 2&gt;3 # is 2 equal to 2 AND greater than 3? ## [1] FALSE 2==2 | 2&gt;3 # is 2 equal to 2 OR greater than 3? ## [1] TRUE These commands will become very useful when we want to subset data or look at portions of our data based on some condition 4.0.4 Character Character is a string of text: letters, numbers, and symbols, cannot perform mathematical operations Character values require quotation marks around each value character&lt;-c(&quot;one&quot;,&quot;two&quot;,&quot;7&quot;,&quot;orange&quot;) 4.0.4.1 Dates Dates are a specific type of character class Specific dates Can do days, weeks, months, quarters, years today&lt;-Sys.Date() #print today&#39;s date format(today, format=&quot;%B %d %Y&quot;) # specify how to report date format ## [1] &quot;December 15 2018&quot; months&lt;-seq(as.Date(&quot;2010/1/1&quot;), as.Date(&quot;2012/1/1&quot;), &quot;months&quot;) # generate sequence of months between Jan 2010 and Jan 2012 months ## [1] &quot;2010-01-01&quot; &quot;2010-02-01&quot; &quot;2010-03-01&quot; &quot;2010-04-01&quot; &quot;2010-05-01&quot; ## [6] &quot;2010-06-01&quot; &quot;2010-07-01&quot; &quot;2010-08-01&quot; &quot;2010-09-01&quot; &quot;2010-10-01&quot; ## [11] &quot;2010-11-01&quot; &quot;2010-12-01&quot; &quot;2011-01-01&quot; &quot;2011-02-01&quot; &quot;2011-03-01&quot; ## [16] &quot;2011-04-01&quot; &quot;2011-05-01&quot; &quot;2011-06-01&quot; &quot;2011-07-01&quot; &quot;2011-08-01&quot; ## [21] &quot;2011-09-01&quot; &quot;2011-10-01&quot; &quot;2011-11-01&quot; &quot;2011-12-01&quot; &quot;2012-01-01&quot; 4.0.5 Factor Factor is a special type of character variable, often used to indicate membership in one of several possible categories, called levels (e.g. for plotting, or conditional statistics and data work) students&lt;-factor(c(&quot;freshman&quot;, &quot;senior&quot;, &quot;senior&quot;, &quot;junior&quot;, &quot;freshman&quot;, &quot;sophomore&quot;, &quot;freshman&quot;)) students # note order is arbitrary ## [1] freshman senior senior junior freshman sophomore freshman ## Levels: freshman junior senior sophomore levels(students) #extract unique levels ## [1] &quot;freshman&quot; &quot;junior&quot; &quot;senior&quot; &quot;sophomore&quot; nlevels(students) #count the number of levels ## [1] 4 table(students) #tabulate number of values for each level ## students ## freshman junior senior sophomore ## 3 1 2 1 4.0.5.1 Ordered Factors Factors have ordered levels() which control the order on plots and in table() students.o&lt;-ordered(students, levels=c(&quot;freshman&quot;,&quot;sophomore&quot;,&quot;junior&quot;,&quot;senior&quot;)) students.o ## [1] freshman senior senior junior freshman sophomore freshman ## Levels: freshman &lt; sophomore &lt; junior &lt; senior Be advised: when R stores and calls factors, it actually stores them as integers [1..k, for k categories] instead of characters (e.g. “freshman”=1, “sophomore”=2), making this a nominal variable. This allows for some mathematical operations. An ordered factor is where the ordering matters (e.g. “small”, “medium”, “large” coded as 1, 2, 3 in order) 4.1 Checking or Reclassifying Objects We can always check the class of an object with class() or typeof(). We can perform logical tests is.numeric(), is.factor(), etc. to see if an object is a specified type We can change the class of an object by redefining it with as.classname(), e.g. x&lt;-1:5 is.numeric(x) # check if x is numeric ## [1] TRUE is.factor(x) # check if x is a character ## [1] FALSE x&lt;-as.character(x) # change vector x to a character class(x) ## [1] &quot;character&quot; x&lt;-as.numeric(x) # change vector x back to numeric class(x) ## [1] &quot;numeric&quot; "],
["data-wrangling.html", "Data Wrangling 4.2 Packages 4.3 Importing Data 4.4 Merging Data 4.5 Using the %&gt;% “Pipe” Operator 4.6 Subsetting 4.7 ", " Data Wrangling 90% of data work is “wrangling” raw data files into something we can actually work with There are perhaps 5 common tasks that most data analysis will require some combination of: 1. Importing data (from an external source) 2. Merging data (from multiple sources) 3. Tidying data (transforming it to a useful structure) 4. Subsetting data (for conditional analysis) 5. Summarizing data (in summary statistics and plots) 4.2 Packages All of the tasks in this section can be undertaken with base R commands. However, several packages make these tasks much more efficient and intuitive to understand and document. - dplyr - tidyr - readr 4.3 Importing Data getwd() setwd() list.files() list.dirs() 4.4 Merging Data A simple merge 4.5 Using the %&gt;% “Pipe” Operator 4.6 Subsetting 4.7 "],
["plotting.html", "Chapter 5 Plotting 5.1 Plotting in Base R 5.2 With ggplot2", " Chapter 5 Plotting Data visualization is one of the most useful tools and gives you the most “bang for your buck.” Base R is very powerful and intuitive to plot, but is not very aesthetically pleasing or advanced. We also use the ggplot2 package, part of the tidyverse to suit our advanced plotting needs. 5.1 Plotting in Base R The basic syntax is quite simple, put the variable(s) you wish to plot (which come from a dataframe) inside the argument of a plot function: plottype(my_df$my_variable1, my_df$my_variable2) If you are using multiple variables, you can avoid having to invoke the same dataframe and $ multiple times by just including the names of the variables in the dataframe, and then add , data=my_df as the final argument of the function, e.g. plottype(my_variable1, my_variable_2, data=my_df) The three simple plots that we can look at are Function Plot Type When Used hist() Histogram Exploring the distribution of a single variable barplot() Bar Graph Exploring the counts of different categories of a variable boxplot() Boxplot Exploring the distribution of a single variable plot() Scatterplot Exploring the relationship between two variables 5.1.1 Histogram library(&quot;gapminder&quot;) hist(gapminder$gdpPercap) 5.1.2 Boxplot Boxplots are similar syntax boxplot(gapminder$gdpPercap) If we want a boxplot for each category, use variable.name~category.variable.name to tell R to plot a boxplot by category boxplot(gdpPercap~continent,data=gapminder) 5.1.3 Scatterplot Scatterplot syntax for plotting is similar to hist() and boxplot(): plot(df$x,df$y) plot(gapminder$gdpPercap, gapminder$lifeExp) 5.2 With ggplot2 `ggplot2 is one of the premier packages at the center of the tidyverse. It is very powerful and creates beautiful data visualizations, but has a steeper learning curve at first. All of those “cool graphics” you see in media outlets such as the New York Times, fivethirtyeight, Vox, the Economist, etc use something are based off of ggplot2. The gg stands for a “grammar of graphics” 5.2.1 Two Ways to Plot Just the single ggplot command Will view plot right after producing it Does not save as an object Need to rerun or copy/paste full command producing plot in order to modify or view it again Can still put it in a document ggplot(...) # make and view plot ggplot(some.options) # remake plot with new options and view plot 5.2.2 Two Ways to Plot II Create an object (as usual in R) This allows you to save the plot for later (re)use Also allows you to modify it Any time you want to view display it (i.e. for putting it in a document), just call up the plot by name plot.name&lt;-ggplot(...) # make plot plot.name&lt;-plot.name+some.options # add new options to existing plot plot.name # view plot plot.name&lt;-ggplot(data=mydf, mapping=aes(x=xvar,y=yvar))+ geom_something(options)+ moreoptions... gg “grammar of graphics” implies any graphic can be built from the same components/layers: Data: base-layer describes the data used mydf is the dataframe containing xvar and yvar aes() “aesthetics” identifies xvar (and if applicable yvar) from data to be “mapped” to a visual mark Geoms: visual marks that represent data observations or models, common examples: e.g. geom_point, geom_line, geom_bar, geom_histogram, geom_density, geom_boxplot Coordinates: Cartesian coordinates are default change scales, axes, labels, etc; advanced options like maps Most important idea to master is aes() aesthetics that map data to visual markings Aesthetics come in many forms and many options, depending on the context of the data Must identify position (e.g. what is x and y) Determine the marking with various geoms (points, bars, lines, boxes, etc) Can pass additional options into geom (color, size, shape, etc) Particularly important if we want color, size, or shape to depend on a particular variable in dataset For our example, we’ll use the mpg dataset loaded with the ggplot2 package library(&quot;ggplot2&quot;) #load ggplot2 mpg #look at dataset ## # A tibble: 234 x 11 ## manufacturer model displ year cyl trans drv cty hwy fl ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; ## 1 audi a4 1.8 1999 4 auto(l… f 18 29 p ## 2 audi a4 1.8 1999 4 manual… f 21 29 p ## 3 audi a4 2 2008 4 manual… f 20 31 p ## 4 audi a4 2 2008 4 auto(a… f 21 30 p ## 5 audi a4 2.8 1999 6 auto(l… f 16 26 p ## 6 audi a4 2.8 1999 6 manual… f 18 26 p ## 7 audi a4 3.1 2008 6 auto(a… f 18 27 p ## 8 audi a4 quat… 1.8 1999 4 manual… 4 18 26 p ## 9 audi a4 quat… 1.8 1999 4 auto(l… 4 16 25 p ## 10 audi a4 quat… 2 2008 4 manual… 4 20 28 p ## # ... with 224 more rows, and 1 more variable: class &lt;chr&gt; 5.2.3 gg Histogram: Base Layer Start with the base layer: establish the data source, define \\(x\\) variable mpg.h&lt;-ggplot(data=mpg,mapping=aes(x=hwy)) mpg.h 5.2.4 gg Histogram: Adding Geoms Add a histogram layer of hwy mpg.h1&lt;-mpg.h+geom_histogram() mpg.h1 5.2.5 gg Histogram: Customizing Geoms Edit the histogram (# of bins, color, etc) mpg.h2&lt;-mpg.h+geom_histogram(bins=20, color=&quot;black&quot;,fill=&quot;indianred&quot;) mpg.h2 5.2.6 gg Histogram: Adding Other Layers Add a vertical line for the mean with another geom called vline mpg.h2&lt;-mpg.h2+ geom_vline(xintercept=mean(mpg$hwy),linetype=&quot;dotted&quot;,color=&quot;blue&quot;,size=1) mpg.h2 5.2.7 gg Histogram: Editing Coordinates (Axes) Change the labels on the axes with xlab() and ylab() mpg.h2&lt;-mpg.h2+xlab(&quot;Miles Per Gallon (on Highway)&quot;)+ylab(&quot;Number of Cars&quot;) mpg.h2 5.2.8 gg Other Geoms How about a density plot: use geom_density() instead of geom_histogram() mpg.d&lt;-ggplot(data=mpg,aes(x=hwy))+ geom_density(fill=&quot;indianred&quot;) mpg.d 5.2.9 gg Other Geoms Let’s make a separate density plot for each class, set aes to fill by class mpg.d&lt;-ggplot(data=mpg,aes(x=hwy,fill=class))+ geom_density(alpha=0.5) # alpha adds transparency mpg.d 5.2.10 gg Boxplot Instead of a density plot, a boxplot by class (note now x is class and y is hwy): mpg.b&lt;-ggplot(data=mpg,aes(x=class,y=hwy,fill=class))+ geom_boxplot() mpg.b 5.2.11 Scatterplot Start with the base layer: establish data source, define \\(x\\) and \\(y\\) variables mpg.p&lt;-ggplot(data=mpg,aes(x=displ, y=hwy)) #use mtcars df, let x=displ, y=hwy mpg.p 5.2.12 Scatterplot: Geom Layer mpg.p&lt;-mpg.p+geom_point() # specify observations as points on graph mpg.p 5.2.13 Scatterplot: Geom Layer Options mpg.p&lt;-mpg.p+geom_point(aes(color=manufacturer)) # color data points by manuf. mpg.p 5.2.14 Scatterplot: Geom Layer II mpg.p&lt;-mpg.p+geom_smooth(method=&quot;lm&quot;, color=&quot;black&quot;) # add a black OLS line mpg.p 5.2.15 Scatterplot: Coordinate Layer mpg.p&lt;-mpg.p+xlab(&quot;Engine Displacement (Liters)&quot;)+ ylab(&quot;Miles Per Gallon on Highway&quot;) mpg.p 5.2.16 Scatterplot: Coordinate Options Let’s have some fun changing the theme library(&quot;ggthemes&quot;) # need ggthemes package (install if first use) mpg.p&lt;-mpg.p+theme_economist_white() #make it look like The Economist magazine mpg.p 5.2.17 Scatterplot: Coordinate Options II mpg.p&lt;-mpg.p+theme_fivethirtyeight() #make it look like fivethirtyeight mpg.p 5.2.18 Scatterplot: Coordinate Options: Facetting # make columns of separate &#39;facet&#39; figures for each class of car mpg.p&lt;-mpg.p+facet_grid(cols = vars(class)) # make &#39;columns&#39; by variable &#39;class&#39; mpg.p 5.2.19 All Together Now ggplot(data=mpg,aes(x=displ, y=hwy))+geom_point(aes(color=manufacturer))+ geom_smooth(color=&quot;black&quot;,method=&quot;lm&quot;)+ xlab(&quot;Engine Displacement (Liters)&quot;)+ylab(&quot;Miles Per Gallon on Highway&quot;)+ theme_fivethirtyeight()+facet_grid(cols = vars(class)) 5.2.20 Advanced Uses of ggplot2: Maps (See Rmd for Code) "],
["regression-basics.html", "Chapter 6 Regression Basics 6.1 Ordinary Least Squares (OLS) Regression 6.2 Prediction 6.3 Residual Plots 6.4 Regression Output Table", " Chapter 6 Regression Basics 6.1 Ordinary Least Squares (OLS) Regression In R, the Ordinary Least Squares (OLS) regression model is simply called the “linear model”, abbreviated lm. Regressions are run on several variables from a data.frame and stored as a lm object that we can inspect and modify. set.seed=1 #makes &#39;random&#39; draws reproducible x&lt;-runif(500,min=0,max=10) #500 draws from uniform distr y&lt;-2*x+rnorm(500,2,4) my_df&lt;-data.frame(x,y) ggplot(my_df, aes(x=x,y=y))+ geom_point(alpha=0.5)+ geom_smooth(method=&quot;lm&quot;, color=&quot;green&quot;)+ xlim(c(0,10))+theme_light() The syntax for running a regression in R is simple. We store the regression as an lm() object (e.g. called “my_reg”) and regress our dependent (mydf$y) variable on (~) the independent (my_df$x) variable. my_reg&lt;-lm(df$y~df$x) Alternatively, we can simply use the variable names from my_df and then tell R that the variables are coming from my_df: my_reg&lt;-lm(y~x, data = my_df) \\[y=\\beta_0+\\beta_1 x\\] When we inspect our lm object, R simply prints the coefficients (“Intercept” for \\(\\hat{\\beta_0}\\)) and (“x” for \\(\\hat{\\beta_1}\\) on \\(x\\)): my_reg ## ## Call: ## lm(formula = y ~ x, data = my_df) ## ## Coefficients: ## (Intercept) x ## 1.981 1.989 We can get a more detailed summary by running summary() on our lm object. summary(my_reg) ## ## Call: ## lm(formula = y ~ x, data = my_df) ## ## Residuals: ## Min 1Q Median 3Q Max ## -12.812 -2.690 0.015 2.496 14.115 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 1.98145 0.38350 5.167 3.45e-07 *** ## x 1.98865 0.06535 30.431 &lt; 2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 4.153 on 498 degrees of freedom ## Multiple R-squared: 0.6503, Adjusted R-squared: 0.6496 ## F-statistic: 926 on 1 and 498 DF, p-value: &lt; 2.2e-16 The summary() prints: The formula for the regression A 5 number summary of the distribution of the residuals Table of coefficients Column 1: Estimate for each \\(\\beta\\) Column 2: Standard error of each \\(\\beta\\) Column 3: \\(t\\)-statistic for each \\(\\beta\\) with \\(H_0: \\, \\beta=0\\) Column 4: \\(p\\)-value for the \\(t\\)-test Regression Diagnostics Standard error of the regression (SER), R calls it Residual standard error (RSE) R-squared and Adjusted R-squared “All \\(F\\)-test” where \\(H_0: \\text{ all } \\beta\\text{&#39;s}=0\\) Inside the lm object my_reg is stored a lot of things that may not show up in the summary. To get a full inspection, check the structure with str(). str(my_reg) ## List of 12 ## $ coefficients : Named num [1:2] 1.98 1.99 ## ..- attr(*, &quot;names&quot;)= chr [1:2] &quot;(Intercept)&quot; &quot;x&quot; ## $ residuals : Named num [1:500] 3.34 -4.27 2.68 -1.09 -3.48 ... ## ..- attr(*, &quot;names&quot;)= chr [1:500] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; ... ## $ effects : Named num [1:500] -272.62 126.38 2.51 -1.12 -3.61 ... ## ..- attr(*, &quot;names&quot;)= chr [1:500] &quot;(Intercept)&quot; &quot;x&quot; &quot;&quot; &quot;&quot; ... ## $ rank : int 2 ## $ fitted.values: Named num [1:500] 20.21 4.55 13.54 9.26 12.34 ... ## ..- attr(*, &quot;names&quot;)= chr [1:500] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; ... ## $ assign : int [1:2] 0 1 ## $ qr :List of 5 ## ..$ qr : num [1:500, 1:2] -22.3607 0.0447 0.0447 0.0447 0.0447 ... ## .. ..- attr(*, &quot;dimnames&quot;)=List of 2 ## .. .. ..$ : chr [1:500] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; ... ## .. .. ..$ : chr [1:2] &quot;(Intercept)&quot; &quot;x&quot; ## .. ..- attr(*, &quot;assign&quot;)= int [1:2] 0 1 ## ..$ qraux: num [1:2] 1.04 1.06 ## ..$ pivot: int [1:2] 1 2 ## ..$ tol : num 1e-07 ## ..$ rank : int 2 ## ..- attr(*, &quot;class&quot;)= chr &quot;qr&quot; ## $ df.residual : int 498 ## $ xlevels : Named list() ## $ call : language lm(formula = y ~ x, data = my_df) ## $ terms :Classes &#39;terms&#39;, &#39;formula&#39; language y ~ x ## .. ..- attr(*, &quot;variables&quot;)= language list(y, x) ## .. ..- attr(*, &quot;factors&quot;)= int [1:2, 1] 0 1 ## .. .. ..- attr(*, &quot;dimnames&quot;)=List of 2 ## .. .. .. ..$ : chr [1:2] &quot;y&quot; &quot;x&quot; ## .. .. .. ..$ : chr &quot;x&quot; ## .. ..- attr(*, &quot;term.labels&quot;)= chr &quot;x&quot; ## .. ..- attr(*, &quot;order&quot;)= int 1 ## .. ..- attr(*, &quot;intercept&quot;)= int 1 ## .. ..- attr(*, &quot;response&quot;)= int 1 ## .. ..- attr(*, &quot;.Environment&quot;)=&lt;environment: R_GlobalEnv&gt; ## .. ..- attr(*, &quot;predvars&quot;)= language list(y, x) ## .. ..- attr(*, &quot;dataClasses&quot;)= Named chr [1:2] &quot;numeric&quot; &quot;numeric&quot; ## .. .. ..- attr(*, &quot;names&quot;)= chr [1:2] &quot;y&quot; &quot;x&quot; ## $ model :&#39;data.frame&#39;: 500 obs. of 2 variables: ## ..$ y: num [1:500] 23.546 0.278 16.229 8.172 8.86 ... ## ..$ x: num [1:500] 9.17 1.29 5.81 3.66 5.21 ... ## ..- attr(*, &quot;terms&quot;)=Classes &#39;terms&#39;, &#39;formula&#39; language y ~ x ## .. .. ..- attr(*, &quot;variables&quot;)= language list(y, x) ## .. .. ..- attr(*, &quot;factors&quot;)= int [1:2, 1] 0 1 ## .. .. .. ..- attr(*, &quot;dimnames&quot;)=List of 2 ## .. .. .. .. ..$ : chr [1:2] &quot;y&quot; &quot;x&quot; ## .. .. .. .. ..$ : chr &quot;x&quot; ## .. .. ..- attr(*, &quot;term.labels&quot;)= chr &quot;x&quot; ## .. .. ..- attr(*, &quot;order&quot;)= int 1 ## .. .. ..- attr(*, &quot;intercept&quot;)= int 1 ## .. .. ..- attr(*, &quot;response&quot;)= int 1 ## .. .. ..- attr(*, &quot;.Environment&quot;)=&lt;environment: R_GlobalEnv&gt; ## .. .. ..- attr(*, &quot;predvars&quot;)= language list(y, x) ## .. .. ..- attr(*, &quot;dataClasses&quot;)= Named chr [1:2] &quot;numeric&quot; &quot;numeric&quot; ## .. .. .. ..- attr(*, &quot;names&quot;)= chr [1:2] &quot;y&quot; &quot;x&quot; ## - attr(*, &quot;class&quot;)= chr &quot;lm&quot; Note that lm objects are actually lists, (data.frames are also lists), so we can extract elements of the list and subset using $ or [[]]. Some of the important elements of the list: my_reg$coefficients is a list of coefficients my_reg$residuals is a list comprised of the residual for each x value my_reg$fitted.values is a list comprised of the predicted/fitted value (\\(\\hat{y}\\)) for each x value my_reg$coefficients # look at coefficients ## (Intercept) x ## 1.981448 1.988651 my_reg$residuals[1:5] # look at first 5 residuals ## 1 2 3 4 5 ## 3.337679 -4.271690 2.684857 -1.086477 -3.475102 my_reg$fitted.values[1:5] # look at first 5 fitted.values ## 1 2 3 4 5 ## 20.208645 4.550152 13.543741 9.258250 12.335037 These stored values will come in handy. We can run functions on them, for example, to discover things about the residuals: summary(my_reg$residuals) # the same as the first thing printed in the regression output above! ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## -12.81203 -2.68994 0.01504 0.00000 2.49585 14.11466 sd(my_reg$residuals) # the standard deviation of the residuals ## [1] 4.148997 Since these are stored in lm as objects, we can also assign them to new columns in our original data.frame, my_df. This can be helpful for plotting with x, y, the residuals \\(\\epsilon\\), and the predicted values \\(\\hat{y}\\). # save predicted values from model as &quot;yhat&quot; my_df$yhat&lt;-my_reg$fitted.values # save residuals from model as &quot;res&quot; my_df$res&lt;-my_reg$residuals # look at new dataframe kable(head(my_df)) x y yhat res 9.165609 23.5463248 20.208645 3.337679 1.291681 0.2784619 4.550152 -4.271690 5.814138 16.2285979 13.543741 2.684857 3.659165 8.1717731 9.258250 -1.086477 5.206338 8.8599348 12.335037 -3.475102 5.519096 9.7812428 12.957005 -3.175762 There are also specific functions for assigning the predicted values and the residuals to a data.frame, using the lm object as the argument. They will produce the same result as above. # save predicted values from model as &quot;yhat&quot; my_df$yhat&lt;-predict(my_reg) # save residuals from model as &quot;res&quot; my_df$res&lt;-residuals(my_reg) # we get the same result head(my_df) ## x y yhat res ## 1 9.165609 23.5463248 20.208645 3.337679 ## 2 1.291681 0.2784619 4.550152 -4.271690 ## 3 5.814138 16.2285979 13.543741 2.684857 ## 4 3.659165 8.1717731 9.258250 -1.086477 ## 5 5.206338 8.8599348 12.335037 -3.475102 ## 6 5.519096 9.7812428 12.957005 -3.175762 6.1.1 Diagnostics Some of the regression diagnostics are stored (idiosyncratically) in the summary() object, and can be extracted by name: summary(my_reg)$sigma # extract residual squared error (SER) ## [1] 4.153161 summary(my_reg)$r.squared # extract R^2 ## [1] 0.6502903 summary(my_reg)$adj.r.squared # extract adjusted R^2 ## [1] 0.6495881 summary(my_reg)$f # extract the F-statistic ## value numdf dendf ## 926.0382 1.0000 498.0000 These might be useful if we wished to perform manual calculations using these statistics. As an example, if we wanted to calculate the correlation coefficient between \\(X\\) and \\(Y\\), and we know that \\(R^2\\) is the correlation coefficient squared: R2&lt;-summary(my_reg)$r.squared sqrt(R2) ## [1] 0.8064058 # compare to actual correlation coefficient cor(my_df$x, my_df$y) ## [1] 0.8064058 6.2 Prediction We can use the model to make pedictions using the estimated regression model. \\[\\hat{Y}=2.090+1.974X\\] x&lt;-3 prediction&lt;-my_reg$coef[1]+my_reg$coef[2]*x prediction ## (Intercept) ## 7.947401 # multiple predictions x&lt;-c(1,3,7,10) prediction&lt;-my_reg$coef[1]+my_reg$coef[2]*x prediction ## [1] 3.970099 7.947401 15.902006 21.867959 # alternatively, we can use the predict() function and insert # a dataframe of our desired x values to predict y-hat prediction2&lt;-predict(my_reg, data.frame(x=c(1,3,7,10))) prediction2 ## 1 2 3 4 ## 3.970099 7.947401 15.902006 21.867959 6.3 Residual Plots For more, see Plotting{#04-plotting}. ggplot(data = my_df, aes(x = x, y = res))+ geom_point(color=&quot;red&quot;)+ geom_hline(yintercept=0, color=&quot;blue&quot;)+ # add horizontal line at y=0 theme_light() 6.4 Regression Output Table The broom package converts lm objects into a tidy data.frame that can easily be printed in a nice table using knitr’s kable() function for html output. # install.packages(&quot;broom&quot;) # install first if you don&#39;t have library(broom) reg2&lt;-tidy(my_reg) kable(reg2) term estimate std.error statistic p.value (Intercept) 1.981448 0.3835030 5.166708 3e-07 x 1.988651 0.0653498 30.430877 0e+00 stargazer(my_reg, type=&quot;html&quot;) Dependent variable: y x 1.989*** (0.065) Constant 1.981*** (0.384) Observations 500 R2 0.650 Adjusted R2 0.650 Residual Std. Error 4.153 (df = 498) F Statistic 926.038*** (df = 1; 498) Note: p&lt;0.1; p&lt;0.05; p&lt;0.01 "],
["advanced-regression.html", "Chapter 7 Advanced Regression 7.1 Multivariate Regression 7.2 Dummy Variables 7.3 Polynomial Regression", " Chapter 7 Advanced Regression 7.1 Multivariate Regression set.seed(1) x&lt;-rnorm(500,10,2) z&lt;-runif(500,10,20) y&lt;-rnorm(500,2*x*z,2) # generate categorical variables # make a shape variable shapes&lt;-c(&quot;square&quot;,&quot;circle&quot;,&quot;triangle&quot;,&quot;rectangle&quot;,&quot;trapezoid&quot;) shape&lt;-sample(shapes,500,replace=TRUE) # sample 500 random draws with replacement from shapes # make a region variable regions&lt;-c(&quot;north&quot;,&quot;south&quot;,&quot;east&quot;,&quot;west&quot;) region&lt;-sample(regions,500,replace=TRUE) # sample 500 random draws with replacement from regions # make a dummy variable yes&lt;-sample(c(0,1),500,replace=TRUE) # combine into dataframe called df df&lt;-data.frame(x=x, y=y, z=z, shape=factor(shape), region=factor(region), yes=yes) # look at new df head(df) ## x y z shape region yes ## 1 8.747092 264.8931 15.30809 triangle west 1 ## 2 10.367287 347.6574 16.84861 square south 1 ## 3 8.328743 227.9193 13.83283 trapezoid north 1 ## 4 13.190562 517.0824 19.54988 triangle south 1 ## 5 10.659016 235.8301 11.18357 trapezoid west 0 ## 6 8.359063 169.6481 10.39100 triangle west 1 It is quite simply to simply add additional covariates to a regression. In the lm object, we add variables with +. reg1&lt;-lm(y~x+z, data=df) summary(reg1) ## ## Call: ## lm(formula = y ~ x + z, data = df) ## ## Residuals: ## Min 1Q Median 3Q Max ## -47.969 -5.115 -0.013 5.756 42.078 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) -295.7258 3.7549 -78.76 &lt;2e-16 *** ## x 29.4336 0.2671 110.19 &lt;2e-16 *** ## z 20.1389 0.1849 108.94 &lt;2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 12.05 on 497 degrees of freedom ## Multiple R-squared: 0.9809, Adjusted R-squared: 0.9808 ## F-statistic: 1.277e+04 on 2 and 497 DF, p-value: &lt; 2.2e-16 7.2 Dummy Variables reg_d&lt;-lm(y~yes, data=df) summary(reg_d) ## ## Call: ## lm(formula = y ~ yes, data = df) ## ## Residuals: ## Min 1Q Median 3Q Max ## -197.442 -66.094 -8.786 64.039 274.874 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 297.172 5.354 55.506 &lt;2e-16 *** ## yes 1.936 7.809 0.248 0.804 ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 87.16 on 498 degrees of freedom ## Multiple R-squared: 0.0001234, Adjusted R-squared: -0.001884 ## F-statistic: 0.06148 on 1 and 498 DF, p-value: 0.8043 The effect on y of going from “No” to “Yes” is 1.94. If we wanted to make a dummy variable for an existing categorical variable df$north&lt;-ifelse(region==&quot;north&quot;,1,0) df$south&lt;-ifelse(region==&quot;south&quot;,1,0) df$east&lt;-ifelse(region==&quot;east&quot;,1,0) df$west&lt;-ifelse(region==&quot;west&quot;,1,0) head(df) ## x y z shape region yes north south east west ## 1 8.747092 264.8931 15.30809 triangle west 1 0 0 0 1 ## 2 10.367287 347.6574 16.84861 square south 1 0 1 0 0 ## 3 8.328743 227.9193 13.83283 trapezoid north 1 1 0 0 0 ## 4 13.190562 517.0824 19.54988 triangle south 1 0 1 0 0 ## 5 10.659016 235.8301 11.18357 trapezoid west 0 0 0 0 1 ## 6 8.359063 169.6481 10.39100 triangle west 1 0 0 0 1 Here is where a for loop also can come in handy: for(i in unique(df$region)){ region[i]&lt;-ifelse(df$region==i,1,0) } ## Warning in region[i] &lt;- ifelse(df$region == i, 1, 0): number of items to ## replace is not a multiple of replacement length ## Warning in region[i] &lt;- ifelse(df$region == i, 1, 0): number of items to ## replace is not a multiple of replacement length ## Warning in region[i] &lt;- ifelse(df$region == i, 1, 0): number of items to ## replace is not a multiple of replacement length ## Warning in region[i] &lt;- ifelse(df$region == i, 1, 0): number of items to ## replace is not a multiple of replacement length head(df) ## x y z shape region yes north south east west ## 1 8.747092 264.8931 15.30809 triangle west 1 0 0 0 1 ## 2 10.367287 347.6574 16.84861 square south 1 0 1 0 0 ## 3 8.328743 227.9193 13.83283 trapezoid north 1 1 0 0 0 ## 4 13.190562 517.0824 19.54988 triangle south 1 0 1 0 0 ## 5 10.659016 235.8301 11.18357 trapezoid west 0 0 0 0 1 ## 6 8.359063 169.6481 10.39100 triangle west 1 0 0 0 1 7.3 Polynomial Regression "]
]
